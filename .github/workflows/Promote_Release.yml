name: Auto Merge and Tag

on:
  schedule:
    # PROD: every Sunday 00:00 IST == Saturday 18:30 UTC
    - cron: "30 18 * * 6"
    # (For testing you can temporarily use */15 * * * * on default branch)
  workflow_dispatch:
    inputs:
      skip_merge:
        description: "Skip merging PR (tag/release only)"
        required: false
        default: false
        type: boolean
      pr_number:
        description: "Merge this specific PR number (optional)"
        required: false
        type: string

jobs:
  merge-pr:
    # Do not run this job when manually triggered with skip_merge = true
    if: ${{ !(github.event_name == 'workflow_dispatch' && inputs.skip_merge == 'true') }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    outputs:
      pr-merged: ${{ steps.merge_pr.outputs.pr-merged }}
      pr-number: ${{ steps.find_pr.outputs.pr_number }}

    steps:
      - name: Checkout master branch
        uses: actions/checkout@v4
        with:
          ref: master

      - name: Find most recent open release PR to master (or use input)
        id: find_pr
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          INPUT_PR_NUMBER: ${{ inputs.pr_number }}
        run: |
          set -euo pipefail
          REPO="${{ github.repository }}"

          # If pr_number was provided via manual trigger, use it directly
          if [ -n "${INPUT_PR_NUMBER:-}" ]; then
            echo "Manual input provided: PR #${INPUT_PR_NUMBER}"
            PR_NUMBER="$INPUT_PR_NUMBER"
            # Optionally validate it exists and targets master
            PR_DETAIL=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${REPO}/pulls/${PR_NUMBER}")
            STATE=$(echo "$PR_DETAIL" | jq -r '.state // empty')
            BASE=$(echo "$PR_DETAIL"  | jq -r '.base.ref // empty')
            HEAD=$(echo "$PR_DETAIL"  | jq -r '.head.ref // empty')
            if [ "$STATE" != "open" ] || [ "$BASE" != "master" ]; then
              echo "::error::PR #$PR_NUMBER is not open against master (state=$STATE, base=$BASE)."
              exit 1
            fi
          else
            # Auto-discover newest open release PR to master
            PRS_JSON=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${REPO}/pulls?state=open&base=master&per_page=100&sort=updated&direction=desc")

            PR_NUMBER=$(echo "$PRS_JSON" | jq -r '
              map(select(.head.ref | startswith("release/v"))) | first | .number // empty
            ')
            if [ -z "${PR_NUMBER:-}" ]; then
              echo "::notice::No open release PR (release/v*) into master found. Exiting."
              echo "pr_number=" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            echo "Auto-selected release PR #$PR_NUMBER"
            PR_DETAIL=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${REPO}/pulls/${PR_NUMBER}")
          fi

          # Poll until mergeable is computed
          ATTEMPTS=5
          SLEEP_SECS=2
          MERGEABLE=$(echo "$PR_DETAIL" | jq -r '.mergeable')
          MERGEABLE_STATE=$(echo "$PR_DETAIL" | jq -r '.mergeable_state // ""')

          i=1
          while { [ "$MERGEABLE" = "null" ] || [ -z "$MERGEABLE_STATE" ]; } && [ $i -lt $ATTEMPTS ]; do
            sleep $SLEEP_SECS
            PR_DETAIL=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${REPO}/pulls/${PR_NUMBER}")
            MERGEABLE=$(echo "$PR_DETAIL" | jq -r '.mergeable')
            MERGEABLE_STATE=$(echo "$PR_DETAIL" | jq -r '.mergeable_state // ""')
            i=$((i+1))
          done

          echo "Found PR #$PR_NUMBER  mergeable=$MERGEABLE  state=$MERGEABLE_STATE"
          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          echo "mergeable=$MERGEABLE" >> "$GITHUB_OUTPUT"
          echo "mergeable_state=$MERGEABLE_STATE" >> "$GITHUB_OUTPUT"

      - name: Check for conflicts and mergeability
        id: check_status
        if: ${{ steps.find_pr.outputs.pr_number != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR_NUMBER='${{ steps.find_pr.outputs.pr_number }}'
          MERGEABLE='${{ steps.find_pr.outputs.mergeable }}'
          MERGEABLE_STATE='${{ steps.find_pr.outputs.mergeable_state }}'
          echo "::notice::PR #$PR_NUMBER mergeable=$MERGEABLE, mergeable_state=$MERGEABLE_STATE"

          # Only proceed when mergeable=true and state=clean
          if [ "$MERGEABLE" != "true" ] || [ "$MERGEABLE_STATE" != "clean" ]; then
            echo "::notice::Release PR #$PR_NUMBER cannot be merged automatically."
            curl -s -X POST -H "Authorization: token $GITHUB_TOKEN" \
              -H "Content-Type: application/json" \
              -d '{"body":"⚠️ **AUTOMATIC MERGE FAILED:** This pull request could not be merged automatically due to conflicts, required checks, or protections. Please resolve them manually."}' \
              "https://api.github.com/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" >/dev/null
            exit 1
          fi

      - name: Merge the Pull Request (squash + delete branch)
        id: merge_pr
        if: ${{ success() && steps.find_pr.outputs.pr_number != '' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # gh reads GH_TOKEN
        run: |
          set -euo pipefail
          gh pr merge '${{ steps.find_pr.outputs.pr_number }}' --squash --delete-branch --repo '${{ github.repository }}'
          echo "pr-merged=true" >> "$GITHUB_OUTPUT"

  release-tag:
    runs-on: ubuntu-latest
    needs: merge-pr
    # Run if merge happened OR manual tag-only requested
    if: ${{ always() && (needs.merge-pr.outputs.pr-merged == 'true' || (github.event_name == 'workflow_dispatch' && inputs.skip_merge == 'true')) }}
    permissions:
      contents: write

    steps:
      - name: Checkout master branch
        uses: actions/checkout@v4
        with:
          ref: master

      # GROUPED "sub-steps": tag + release
      - name: Tag master and create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # for gh CLI
        shell: bash
        run: |
          set -euo pipefail

          echo "::group::Ensure latest master"
          git config --global user.name  "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git fetch origin master --tags
          git checkout master
          git pull --ff-only origin master
          echo "::endgroup::"

          echo "::group::Compute version and tag"
          VERSION=$(jq -r '.version' package.json)
          if [ -z "$VERSION" ] || [ "$VERSION" = "null" ]; then
            echo "Could not read version from package.json" >&2
            exit 1
          fi
          TAG="v${VERSION}"
          echo "Resolved tag: $TAG"
          echo "::endgroup::"

          echo "::group::Create tag (if missing) and push"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping tag creation."
          else
            git tag -a "$TAG" -m "Release $TAG"
            git push origin "$TAG"
          fi
          echo "::endgroup::"

          echo "::group::Create or update GitHub Release"
          # Find previous tag (second newest by date). If none, include all commits.
          PREV_TAG=$(git tag --sort=-creatordate | sed -n '2p' || true)
          if [ -n "$PREV_TAG" ]; then
            RANGE="${PREV_TAG}..${TAG}"
          else
            RANGE="${TAG}"
          fi

          NOTES=$(git log --pretty=format:'- %s' --reverse $RANGE || true)

          if [ -z "$NOTES" ]; then
            echo "No commit notes found, using auto-generated notes."
            if gh release view "$TAG" >/dev/null 2>&1; then
              gh release edit "$TAG" --title "$TAG" --generate-notes
            else
              gh release create "$TAG" --title "$TAG" --generate-notes
            fi
          else
            if gh release view "$TAG" >/dev/null 2>&1; then
              gh release edit "$TAG" --title "$TAG" --notes "$NOTES"
            else
              gh release create "$TAG" --title "$TAG" --notes "$NOTES"
            fi
          fi
          echo "::endgroup::"
