name: Promote Release PR (Merge, Tag, Release, Sync Back)

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to promote (targets master)"
        required: false
      tag:
        description: "Optional tag to create (defaults to package.json version on master after merge)"
        required: false
  pull_request:
    types: [labeled]
    branches: [master]

permissions:
  contents: write
  pull-requests: write

jobs:
  maybe_promote:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'release')) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve PR number
        id: resolve
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR_INPUT="${{ inputs.pr_number || '' }}"
          if [ -n "$PR_INPUT" ]; then
            PR="$PR_INPUT"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            PR="${{ github.event.pull_request.number }}"
          else
            echo "No pr_number input and not a PR event; discovering latest open release PR to master..."
            PR=$(gh pr list --state open --base master --json number,headRefName,title,labels,updatedAt |               jq -r '[ .[]
                | select(
                    ( (.labels|map(.name)|index("release")) != null )
                    or (.headRefName|startswith("release/"))
                    or (.title|test("(?i)\brelease\b"))
                  )
              ] | sort_by(.updatedAt) | reverse | (.[0].number // empty)')
          fi

          if [ -z "${PR:-}" ]; then
            echo "No open release PR targeting master found. Provide 'pr_number' when dispatching." >&2
            exit 1
          fi
          echo "pr=$PR" >> "$GITHUB_OUTPUT"
          echo "PR=$PR"

          gh pr view "$PR" --json number,state,baseRefName,headRefName,isCrossRepository > pr.json
          BASE=$(jq -r '.baseRefName' pr.json)
          STATE=$(jq -r '.state' pr.json)
          if [ "$BASE" != "master" ]; then
            echo "PR base is '$BASE', expected 'master'"; exit 1
          fi
          if [ "$STATE" != "OPEN" ]; then
            echo "PR is not open: $STATE"; exit 1
          fi

      - name: Check mergeability & conflicts
        id: mergeable
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          q='query($n:Int!){ repository(owner:"${{ github.repository_owner }}", name:"${{ github.event.repository.name }}"){ pullRequest(number:$n){ mergeable state } } }'
          jq -n --argjson n "${{ steps.resolve.outputs.pr }}" '{query:"'${q}'",variables:{n:$n}}' > gql.json
          curl -s -H "Authorization: bearer $GH_TOKEN" -H "Content-Type: application/json" -d @gql.json https://api.github.com/graphql > gql.out.json
          cat gql.out.json
          MERGEABLE=$(jq -r '.data.repository.pullRequest.mergeable' gql.out.json)
          PRSTATE=$(jq -r '.data.repository.pullRequest.state' gql.out.json)
          echo "mergeable=$MERGEABLE" >> "$GITHUB_OUTPUT"
          echo "state=$PRSTATE" >> "$GITHUB_OUTPUT"
          if [ "$MERGEABLE" = "CONFLICTING" ]; then
            echo "PR has conflicts. Resolve conflicts before promoting."; exit 1
          fi

      - name: Merge PR (squash)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          gh pr merge "${{ steps.resolve.outputs.pr }}" --squash --delete-branch --admin --subject "chore(release): merge release PR"

      - name: Determine tag version
        id: tagv
        run: |
          set -euo pipefail
          git checkout master
          git pull --ff-only origin master
          PKG_FILE="package.json"
          if [ -n "${{ inputs.tag || '' }}" ]; then
            TAG="${{ inputs.tag }}"
          else
            if [ -f "$PKG_FILE" ]; then
              TAG="v$(jq -r '.version' "$PKG_FILE")"
            else
              echo "package.json not found; please pass 'tag' input."
              exit 1
            fi
          fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "Using tag: $TAG"

      - name: Create tag (idempotent) and push
        run: |
          set -euo pipefail
          TAG="${{ steps.tagv.outputs.tag }}"
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG$"; then
            echo "Tag $TAG already exists on origin; skipping."
          else
            git tag -a "$TAG" -m "Release $TAG"
            git push origin "$TAG"
          fi

      - name: Generate release notes from commits
        id: notes
        run: |
          set -euo pipefail
          TAG="${{ steps.tagv.outputs.tag }}"
          PREV=$(git describe --tags --abbrev=0 --match "v*" "$(git rev-list --tags --max-count=1 --skip=1)" 2>/dev/null || true)
          if [ -n "$PREV" ]; then
            RANGE="${PREV}..${TAG}"
          else
            RANGE="${TAG}"
          fi
          echo "prev_tag=$PREV" >> "$GITHUB_OUTPUT"
          echo "range=$RANGE" >> "$GITHUB_OUTPUT"

          echo "## What's Changed" > RELEASE_NOTES.md
          if [ -n "$PREV" ]; then
            git log --pretty=format:"- %s (%h)" "$RANGE" >> RELEASE_NOTES.md || true
          else
            git log --pretty=format:"- %s (%h)" >> RELEASE_NOTES.md || true
          fi

          echo "Generated release notes:"
          cat RELEASE_NOTES.md

      - name: Create GitHub Release (idempotent, with notes)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ steps.tagv.outputs.tag }}"
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG already exists; skipping."
          else
            gh release create "$TAG" --title "$TAG" --notes-file RELEASE_NOTES.md
          fi

      - name: Sync back master -> develop (open PR)
        id: backsync
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git fetch origin develop:develop --update-head-ok || true
          git checkout -B sync/master-to-develop origin/develop
          git pull --ff-only origin master || true
          if git merge --no-edit master; then
            echo "Merged master into develop"
          else
            echo "Merge failed"; exit 1
          fi
          if git diff --quiet && git diff --cached --quiet; then
            echo "No changes to push for backsync."
            echo "opened=no" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          git push -u origin HEAD || true
          if gh pr list --search "in:title sync master to develop" --state open --base develop --json number | jq -e 'length>0' >/dev/null; then
            echo "Backsync PR already open."
            echo "opened=existing" >> "$GITHUB_OUTPUT"
          else
            URL=$(gh pr create --base develop --head $(git rev-parse --abbrev-ref HEAD) --title "chore(sync): master -> develop" --body "Sync master back into develop to keep versions aligned.")
            echo "opened=url" >> "$GITHUB_OUTPUT"
            echo "url=$URL" >> "$GITHUB_OUTPUT"
            echo "BACKSYNC_PR=$URL"
          fi

      - name: Echo summary
        run: |
          echo "PR=${{ steps.resolve.outputs.pr }}"
          echo "TAG=${{ steps.tagv.outputs.tag }}"
          echo "PREV_TAG=${{ steps.notes.outputs.prev_tag }}"
          echo "RANGE=${{ steps.notes.outputs.range }}"
          echo "BACKSYNC_OPENED=${{ steps.backsync.outputs.opened || 'no' }}"
          echo "BACKSYNC_URL=${{ steps.backsync.outputs.url || '' }}"
